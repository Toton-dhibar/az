<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Azure Blob Storage File Manager - Upload, download, and manage files">
    <meta name="author" content="Azure File Manager">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Azure File Manager</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìÅ</text></svg>">
    <style>
        /* CSS Variables for easy theming */
        :root {
            --primary-color: #0078d4;
            --primary-hover: #005bb5;
            --background-color: #f4f4f9;
            --card-background: #fff;
            --text-color: #333;
            --border-radius: 10px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition-speed: 0.3s;
        }

        /* General Styles */
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            margin: 0;
            padding: 20px;
            color: var(--text-color);
            line-height: 1.6;
        }

        #app {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-background);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        #currentPathDisplay {
            font-size: 18px;
            font-weight: bold;
            color: var(--primary-color);
            word-break: break-all;
        }

        .header-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color var(--transition-speed) ease, transform 0.2s ease;
            font-family: inherit;
        }

        button:hover {
            background-color: var(--primary-hover);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* Enhanced Progress Bar with Water Animation */
        #progressBarContainer {
            width: 100%;
            margin-bottom: 20px;
            display: none;
            background-color: var(--card-background);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--box-shadow);
        }

        .progress-wrapper {
            position: relative;
            width: 100%;
            height: 60px;
            background-color: #e8f4fd;
            border-radius: 30px;
            overflow: hidden;
            border: 2px solid var(--primary-color);
        }

        #progressFill {
            position: relative;
            height: 100%;
            width: 0%;
            background: linear-gradient(45deg, #4fc3f7, #29b6f6, #03a9f4, #0288d1);
            background-size: 400% 400%;
            border-radius: 30px;
            transition: width 0.5s ease;
            animation: waterFlow 3s ease-in-out infinite;
            overflow: hidden;
        }

        /* Water wave animation */
        #progressFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.3), 
                transparent);
            animation: wave 2s linear infinite;
        }

        #progressFill::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 50%;
            background: repeating-linear-gradient(
                90deg,
                rgba(255, 255, 255, 0.1) 0px,
                rgba(255, 255, 255, 0.3) 10px,
                rgba(255, 255, 255, 0.1) 20px
            );
            animation: ripple 1.5s ease-in-out infinite;
        }

        @keyframes waterFlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes wave {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes ripple {
            0%, 100% { 
                transform: translateY(0) scaleY(1);
                opacity: 0.3;
            }
            50% { 
                transform: translateY(-5px) scaleY(1.1);
                opacity: 0.6;
            }
        }

        /* Progress Text Container */
        .progress-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
            color: #fff;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }

        .progress-percentage {
            font-size: 18px;
            margin-bottom: 2px;
        }

        .progress-details {
            font-size: 12px;
            opacity: 0.9;
        }

        .upload-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            font-size: 14px;
            color: #666;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            min-width: 120px;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .stat-value {
            font-weight: bold;
            color: var(--primary-color);
        }

        /* Loading Spinner */
        .loading-spinner {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner.show {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Error Message */
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: var(--border-radius);
            margin: 10px 0;
            display: none;
        }

        .error-message.show {
            display: block;
        }

        /* File List Styles */
        #fileList {
            list-style-type: none;
            padding: 0;
            margin: 0;
            min-height: 100px;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--card-background);
            padding: 15px;
            margin: 10px 0;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            position: relative;
        }

        .file-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .file-item:focus-within {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .file-item strong {
            font-weight: bold;
        }

        .file-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Folder items styling */
        .file-item.folder {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border-left: 4px solid #fdcb6e;
        }

        /* Three-Dot Button */
        .three-dot-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            padding: 5px 10px;
            color: var(--text-color);
            transition: color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            width: auto;
            height: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }

        .three-dot-btn:hover {
            color: var(--primary-color);
            background-color: rgba(0, 0, 0, 0.05);
        }

        .three-dot-btn:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Dropdown Menu */
        .dropdown-menu {
            display: none;
            position: absolute;
            right: 10px;
            top: 100%;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            z-index: 100;
            animation: fadeIn var(--transition-speed) ease;
            min-width: 120px;
            margin-top: 5px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-menu button {
            width: 100%;
            padding: 10px 15px;
            text-align: left;
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            transition: background-color var(--transition-speed) ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dropdown-menu button:hover {
            background-color: #f0f0f0;
        }

        .dropdown-menu button:focus {
            background-color: #e8f4fd;
            outline: none;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn var(--transition-speed) ease;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 400px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--primary-color);
        }

        .modal-content .close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            transition: color var(--transition-speed) ease;
            background: none;
            border: none;
            padding: 0;
            width: auto;
            line-height: 1;
        }

        .modal-content .close:hover,
        .modal-content .close:focus {
            color: var(--text-color);
        }

        .modal-content input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            font-family: inherit;
        }

        .modal-content input:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
            border-color: var(--primary-color);
        }

        .modal-content button {
            width: 100%;
            padding: 12px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        .modal-content button:hover {
            background-color: var(--primary-hover);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            header {
                flex-direction: column;
                align-items: stretch;
            }

            .header-actions {
                width: 100%;
            }

            button {
                width: 100%;
                margin: 5px 0;
            }

            .upload-stats {
                flex-direction: column;
                gap: 10px;
            }

            .stat-item {
                width: 100%;
            }

            .progress-percentage {
                font-size: 16px;
            }

            .progress-details {
                font-size: 11px;
            }

            .file-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .dropdown-menu {
                right: 0;
                left: 0;
                margin: 0 10px;
            }
        }

        /* Utility Classes */
        .hidden {
            display: none !important;
        }

        .text-center {
            text-align: center;
        }

        .mt-10 {
            margin-top: 10px;
        }

        .mb-10 {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="app" role="application" aria-label="Azure File Manager">
        <header role="banner">
            <div id="currentPathDisplay" aria-live="polite" aria-atomic="true">Home</div>
            <div class="header-actions">
                <button id="backButton" aria-label="Navigate back to previous folder">
                    <span aria-hidden="true">üîô</span> Back
                </button>
                <button id="createFolderButton" aria-label="Create a new folder">
                    <span aria-hidden="true">üìÇ</span> Create Folder
                </button>
                <button id="uploadButton" aria-label="Upload files">
                    <span aria-hidden="true">üì§</span> Upload File
                </button>
                <input type="file" id="fileInput" style="display:none" multiple aria-label="File input for upload">
            </div>
        </header>

        <!-- Error Message Container -->
        <div id="errorMessage" class="error-message" role="alert" aria-live="assertive"></div>

        <!-- Enhanced Progress Bar -->
        <div id="progressBarContainer" role="status" aria-live="polite" aria-label="Upload progress">
            <div class="progress-wrapper">
                <div id="progressFill" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>
                <div class="progress-info">
                    <div class="progress-percentage" id="progressPercentage">0%</div>
                    <div class="progress-details" id="progressDetails">Preparing upload...</div>
                </div>
            </div>
            <div class="upload-stats">
                <div class="stat-item">
                    <div class="stat-label">Uploaded</div>
                    <div class="stat-value" id="uploadedSize">0 MB</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Remaining</div>
                    <div class="stat-value" id="remainingSize">0 MB</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Total Size</div>
                    <div class="stat-value" id="totalSize">0 MB</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Speed</div>
                    <div class="stat-value" id="uploadSpeed">0 MB/s</div>
                </div>
            </div>
        </div>

        <!-- Loading Spinner -->
        <div id="loadingSpinner" class="loading-spinner" role="status" aria-live="polite">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>

        <main role="main">
            <div id="fileList" role="list" aria-label="Files and folders"></div>
        </main>

        <!-- Modal for Create Folder -->
        <div id="createFolderModal" class="modal" role="dialog" aria-labelledby="modalTitle" aria-modal="true">
            <div class="modal-content">
                <button class="close" aria-label="Close modal">&times;</button>
                <h2 id="modalTitle">Create Folder</h2>
                <input type="text" id="newFolderName" placeholder="Folder Name" aria-label="New folder name" maxlength="255" />
                <button id="createFolderSubmit" type="button">Create</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration - WARNING: SAS URL should be stored securely in production
        // Consider using environment variables or a secure backend service
        const sasUrl = "https://sanu.blob.core.windows.net/test?sp=racwdli&st=2025-04-30T13:49:35Z&se=2027-04-30T21:49:35Z&spr=https&sv=2024-11-04&sr=c&sig=3orxshb95XdK%2BESKPIyw5ISSaRNzxp4OINUE934EYzk%3D";
        const containerUrl = sasUrl.split('?')[0];
        
        // State management
        let currentPath = "";
        let activeDropdown = null;
        let uploadStartTime = 0;
        let totalFileSize = 0;

        // DOM elements cache
        const elements = {
            backButton: null,
            createFolderButton: null,
            uploadButton: null,
            fileInput: null,
            fileList: null,
            currentPathDisplay: null,
            progressBarContainer: null,
            progressFill: null,
            progressPercentage: null,
            progressDetails: null,
            uploadedSize: null,
            remainingSize: null,
            totalSize: null,
            uploadSpeed: null,
            createFolderModal: null,
            newFolderName: null,
            createFolderSubmit: null,
            loadingSpinner: null,
            errorMessage: null
        };

        // Initialize DOM elements
        function initializeElements() {
            elements.backButton = document.getElementById('backButton');
            elements.createFolderButton = document.getElementById('createFolderButton');
            elements.uploadButton = document.getElementById('uploadButton');
            elements.fileInput = document.getElementById('fileInput');
            elements.fileList = document.getElementById('fileList');
            elements.currentPathDisplay = document.getElementById('currentPathDisplay');
            elements.progressBarContainer = document.getElementById('progressBarContainer');
            elements.progressFill = document.getElementById('progressFill');
            elements.progressPercentage = document.getElementById('progressPercentage');
            elements.progressDetails = document.getElementById('progressDetails');
            elements.uploadedSize = document.getElementById('uploadedSize');
            elements.remainingSize = document.getElementById('remainingSize');
            elements.totalSize = document.getElementById('totalSize');
            elements.uploadSpeed = document.getElementById('uploadSpeed');
            elements.createFolderModal = document.getElementById('createFolderModal');
            elements.newFolderName = document.getElementById('newFolderName');
            elements.createFolderSubmit = document.getElementById('createFolderSubmit');
            elements.loadingSpinner = document.getElementById('loadingSpinner');
            elements.errorMessage = document.getElementById('errorMessage');
        }

        // Utility functions
        function showLoading() {
            elements.loadingSpinner.classList.add('show');
        }

        function hideLoading() {
            elements.loadingSpinner.classList.remove('show');
        }

        function showError(message) {
            elements.errorMessage.textContent = message;
            elements.errorMessage.classList.add('show');
            setTimeout(() => {
                elements.errorMessage.classList.remove('show');
            }, 5000);
        }

        function hideError() {
            elements.errorMessage.classList.remove('show');
        }

        function sanitizeInput(input) {
            // Remove invalid characters for file/folder names
            return input.replace(/[<>:"/\\|?*\x00-\x1F]/g, '').trim();
        }

        function validateFolderName(name) {
            const sanitized = sanitizeInput(name);
            if (!sanitized) {
                return { valid: false, error: 'Folder name cannot be empty.' };
            }
            if (sanitized.length > 255) {
                return { valid: false, error: 'Folder name is too long (max 255 characters).' };
            }
            if (sanitized.startsWith('.')) {
                return { valid: false, error: 'Folder name cannot start with a dot.' };
            }
            return { valid: true, sanitized };
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 MB';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Calculate upload speed
        function calculateSpeed(uploadedBytes, startTime) {
            const elapsedTime = (Date.now() - startTime) / 1000; // in seconds
            if (elapsedTime === 0) return 0;
            return uploadedBytes / elapsedTime; // bytes per second
        }

        // Update progress display
        function updateProgressDisplay(loaded, total, fileName) {
            const percent = Math.round((loaded / total) * 100);
            const uploadedMB = formatFileSize(loaded);
            const remainingMB = formatFileSize(total - loaded);
            const totalMB = formatFileSize(total);
            const speed = calculateSpeed(loaded, uploadStartTime);
            const speedMB = formatFileSize(speed) + '/s';

            elements.progressFill.style.width = `${percent}%`;
            elements.progressFill.setAttribute('aria-valuenow', percent);
            elements.progressPercentage.textContent = `${percent}%`;
            elements.progressDetails.textContent = `Uploading ${escapeHtml(fileName)}...`;
            elements.uploadedSize.textContent = uploadedMB;
            elements.remainingSize.textContent = remainingMB;
            elements.totalSize.textContent = totalMB;
            elements.uploadSpeed.textContent = speedMB;
        }

        // List files and folders
        async function listFiles(path = "") {
            try {
                showLoading();
                hideError();
                
                currentPath = path;
                elements.currentPathDisplay.textContent = path || "Home";

                const response = await fetch(`${containerUrl}?restype=container&comp=list&prefix=${encodeURIComponent(path)}&${sasUrl.split('?')[1]}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch files: ${response.status} ${response.statusText}`);
                }

                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, "application/xml");
                
                // Check for XML parsing errors
                const parserError = xml.querySelector('parsererror');
                if (parserError) {
                    throw new Error('Failed to parse response from server');
                }

                const blobs = xml.getElementsByTagName("Blob");
                elements.fileList.innerHTML = "";
                
                const folders = new Set();
                const files = [];

                for (let blob of blobs) {
                    const nameElement = blob.getElementsByTagName("Name")[0];
                    if (!nameElement) continue;
                    
                    const name = nameElement.textContent;
                    const shortName = name.replace(path, "").split("/")[0];

                    if (!shortName) continue; // Skip empty names

                    if (name.endsWith("/") || !shortName.includes(".")) {
                        folders.add(shortName);
                    } else {
                        files.push({ name, shortName });
                    }
                }

                // Display folders first
                folders.forEach(folder => {
                    const folderElement = createFileItem(folder, true);
                    elements.fileList.appendChild(folderElement);
                });

                // Then display files
                files.forEach(file => {
                    const fileElement = createFileItem(file.shortName, false, file.name);
                    elements.fileList.appendChild(fileElement);
                });

                if (elements.fileList.children.length === 0) {
                    elements.fileList.innerHTML = '<p class="text-center mt-10">No files or folders found.</p>';
                }
            } catch (error) {
                console.error('Error listing files:', error);
                showError(`Failed to load files: ${error.message}`);
                elements.fileList.innerHTML = '<p class="text-center mt-10">Failed to load files. Please try again.</p>';
            } finally {
                hideLoading();
            }
        }

        // Create file item element
        function createFileItem(name, isFolder, fullName = null) {
            const item = document.createElement('div');
            item.className = `file-item${isFolder ? ' folder' : ''}`;
            item.setAttribute('role', 'listitem');
            item.setAttribute('tabindex', '0');

            const fileInfo = document.createElement('div');
            fileInfo.className = 'file-info';
            
            const icon = document.createElement('span');
            icon.setAttribute('aria-hidden', 'true');
            icon.textContent = isFolder ? 'üìÅ ' : 'üìÑ ';
            
            const nameSpan = document.createElement('strong');
            nameSpan.textContent = name;
            
            fileInfo.appendChild(icon);
            fileInfo.appendChild(nameSpan);

            const menuButton = document.createElement('button');
            menuButton.className = 'three-dot-btn';
            menuButton.setAttribute('aria-label', `Options for ${name}`);
            menuButton.setAttribute('aria-haspopup', 'true');
            menuButton.textContent = '‚ãÆ';

            const dropdown = createDropdownMenu(name, isFolder, fullName);

            item.appendChild(fileInfo);
            item.appendChild(menuButton);
            item.appendChild(dropdown);

            // Event listeners
            item.addEventListener('dblclick', () => {
                if (isFolder) {
                    navigateToFolder(name);
                } else {
                    downloadFile(fullName || name);
                }
            });

            item.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    if (isFolder) {
                        navigateToFolder(name);
                    } else {
                        downloadFile(fullName || name);
                    }
                }
            });

            menuButton.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleDropdown(e, dropdown);
            });

            return item;
        }

        // Create dropdown menu
        function createDropdownMenu(name, isFolder, fullName = null) {
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu';
            dropdown.setAttribute('role', 'menu');

            const actions = isFolder ? [
                { icon: 'üìÇ', text: 'Open', handler: () => navigateToFolder(name) },
                { icon: '‚úèÔ∏è', text: 'Rename', handler: () => renameFolder(name) },
                { icon: 'üîó', text: 'Copy Link', handler: () => copyLink(name) },
                { icon: 'üóëÔ∏è', text: 'Delete', handler: () => confirmDeleteFolder(name) }
            ] : [
                { icon: 'üì•', text: 'Download', handler: () => downloadFile(fullName || name) },
                { icon: '‚úèÔ∏è', text: 'Rename', handler: () => renameFile(fullName || name) },
                { icon: 'üîó', text: 'Copy Link', handler: () => copyLink(fullName || name) },
                { icon: 'üóëÔ∏è', text: 'Delete', handler: () => confirmDelete(fullName || name) }
            ];

            actions.forEach(action => {
                const button = document.createElement('button');
                button.setAttribute('role', 'menuitem');
                button.innerHTML = `<span aria-hidden="true">${action.icon}</span> ${action.text}`;
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    closeAllDropdowns();
                    action.handler();
                });
                dropdown.appendChild(button);
            });

            return dropdown;
        }

        // Toggle dropdown menu
        function toggleDropdown(event, dropdown) {
            event.stopPropagation();
            
            if (activeDropdown && activeDropdown !== dropdown) {
                activeDropdown.classList.remove('show');
            }
            
            dropdown.classList.toggle('show');
            activeDropdown = dropdown.classList.contains('show') ? dropdown : null;

            if (activeDropdown) {
                const firstButton = activeDropdown.querySelector('button');
                if (firstButton) firstButton.focus();
            }
        }

        // Close all dropdowns
        function closeAllDropdowns() {
            if (activeDropdown) {
                activeDropdown.classList.remove('show');
                activeDropdown = null;
            }
        }

        // Navigate into folders
        function navigateToFolder(folderName) {
            currentPath = currentPath ? `${currentPath}${folderName}/` : `${folderName}/`;
            listFiles(currentPath);
        }

        // Go back to the previous folder
        function goBack() {
            if (!currentPath) return;
            const parts = currentPath.split("/").filter(Boolean);
            parts.pop();
            currentPath = parts.length ? parts.join("/") + "/" : "";
            listFiles(currentPath);
        }

        // Upload files with enhanced progress bar and error handling
        async function uploadFile() {
            const files = elements.fileInput.files;
            
            if (files.length === 0) {
                showError("No files selected for upload.");
                return;
            }

            try {
                // Calculate total file size
                totalFileSize = 0;
                for (let file of files) {
                    totalFileSize += file.size;
                }

                // Validate file size (example: max 5GB total)
                const maxSize = 5 * 1024 * 1024 * 1024; // 5GB
                if (totalFileSize > maxSize) {
                    showError("Total file size exceeds 5GB limit.");
                    return;
                }

                elements.progressBarContainer.style.display = "block";
                uploadStartTime = Date.now();

                let totalUploaded = 0;
                let uploadErrors = [];

                for (let file of files) {
                    try {
                        const sanitizedFileName = sanitizeInput(file.name);
                        if (!sanitizedFileName) {
                            uploadErrors.push(`Invalid file name: ${file.name}`);
                            continue;
                        }

                        const blobUrl = `${containerUrl}/${currentPath}${encodeURIComponent(sanitizedFileName)}?${sasUrl.split('?')[1]}`;
                        
                        await new Promise((resolve, reject) => {
                            const xhr = new XMLHttpRequest();

                            xhr.upload.onprogress = (event) => {
                                if (event.lengthComputable) {
                                    const currentFileUploaded = event.loaded;
                                    const totalUploadedSoFar = totalUploaded + currentFileUploaded;
                                    updateProgressDisplay(totalUploadedSoFar, totalFileSize, sanitizedFileName);
                                }
                            };

                            xhr.onload = () => {
                                if (xhr.status === 201) {
                                    totalUploaded += file.size;
                                    console.log(`Upload complete for ${sanitizedFileName}!`);
                                    resolve();
                                } else {
                                    reject(new Error(`Upload failed with status: ${xhr.status}`));
                                }
                            };

                            xhr.onerror = () => {
                                reject(new Error('Network error during upload'));
                            };

                            xhr.ontimeout = () => {
                                reject(new Error('Upload timed out'));
                            };

                            xhr.open("PUT", blobUrl, true);
                            xhr.setRequestHeader("x-ms-blob-type", "BlockBlob");
                            xhr.timeout = 300000; // 5 minutes timeout
                            xhr.send(file);
                        });
                    } catch (error) {
                        console.error(`Error uploading ${file.name}:`, error);
                        uploadErrors.push(`${file.name}: ${error.message}`);
                    }
                }

                // Reset file input
                elements.fileInput.value = '';

                if (uploadErrors.length > 0) {
                    elements.progressDetails.textContent = "Upload completed with errors";
                    showError(`Some files failed to upload:\n${uploadErrors.join('\n')}`);
                    setTimeout(() => {
                        elements.progressBarContainer.style.display = "none";
                        listFiles(currentPath);
                    }, 3000);
                } else {
                    elements.progressDetails.textContent = "Upload completed!";
                    setTimeout(() => {
                        elements.progressBarContainer.style.display = "none";
                        listFiles(currentPath);
                    }, 2000);
                }
            } catch (error) {
                console.error('Upload error:', error);
                showError(`Upload failed: ${error.message}`);
                elements.progressBarContainer.style.display = "none";
                elements.fileInput.value = '';
            }
        }

        // Download a file using SAS URL
        function downloadFile(fileName) {
            try {
                const blobUrl = `${containerUrl}/${encodeURIComponent(fileName)}?${sasUrl.split('?')[1]}`;
                window.open(blobUrl, "_blank");
            } catch (error) {
                console.error('Download error:', error);
                showError(`Failed to download file: ${error.message}`);
            }
        }

        // Modal functions
        function openCreateFolderModal() {
            elements.createFolderModal.classList.add("show");
            elements.newFolderName.value = '';
            elements.newFolderName.focus();
        }

        function closeCreateFolderModal() {
            elements.createFolderModal.classList.remove("show");
            elements.newFolderName.value = '';
        }

        // Create a folder in the current path
        async function createFolder() {
            const folderName = elements.newFolderName.value;
            const validation = validateFolderName(folderName);

            if (!validation.valid) {
                showError(validation.error);
                return;
            }

            try {
                const sanitizedName = validation.sanitized;
                const folderPath = `${currentPath}${sanitizedName}/`;
                const blobUrl = `${containerUrl}/${encodeURIComponent(folderPath)}?${sasUrl.split('?')[1]}`;

                const response = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open("PUT", blobUrl, true);
                    xhr.setRequestHeader("x-ms-blob-type", "BlockBlob");
                    xhr.onload = () => resolve(xhr);
                    xhr.onerror = () => reject(new Error('Network error'));
                    xhr.ontimeout = () => reject(new Error('Request timed out'));
                    xhr.timeout = 30000;
                    xhr.send();
                });

                if (response.status === 201) {
                    closeCreateFolderModal();
                    await listFiles(currentPath);
                } else {
                    showError("Failed to create folder. Please try again.");
                }
            } catch (error) {
                console.error('Create folder error:', error);
                showError(`Failed to create folder: ${error.message}`);
            }
        }

        // Confirm before deleting a file
        function confirmDelete(fileName) {
            const confirmation = confirm(`Are you sure you want to delete "${fileName}"?`);
            if (confirmation) {
                deleteFile(fileName);
            }
        }

        // Delete file
        async function deleteFile(fileName) {
            try {
                const blobUrl = `${containerUrl}/${encodeURIComponent(fileName)}?${sasUrl.split('?')[1]}`;
                
                const response = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open("DELETE", blobUrl, true);
                    xhr.onload = () => resolve(xhr);
                    xhr.onerror = () => reject(new Error('Network error'));
                    xhr.ontimeout = () => reject(new Error('Request timed out'));
                    xhr.timeout = 30000;
                    xhr.send();
                });

                if (response.status === 202) {
                    await listFiles(currentPath);
                } else {
                    showError("Failed to delete file. Please try again.");
                }
            } catch (error) {
                console.error('Delete error:', error);
                showError(`Failed to delete file: ${error.message}`);
            }
        }

        // Confirm before deleting a folder
        function confirmDeleteFolder(folderName) {
            const confirmation = confirm(`Are you sure you want to delete the folder "${folderName}"? This will delete all files inside it.`);
            if (confirmation) {
                deleteFolder(folderName);
            }
        }

        // Delete folder and its contents
        async function deleteFolder(folderName) {
            try {
                showLoading();
                const folderPath = `${currentPath}${folderName}/`;
                const response = await fetch(`${containerUrl}?restype=container&comp=list&prefix=${encodeURIComponent(folderPath)}&${sasUrl.split('?')[1]}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch folder contents');
                }

                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, "application/xml");
                const blobs = xml.getElementsByTagName("Blob");

                const deletePromises = [];
                for (let blob of blobs) {
                    const nameElement = blob.getElementsByTagName("Name")[0];
                    if (!nameElement) continue;
                    
                    const fileName = nameElement.textContent;
                    const fileUrl = `${containerUrl}/${encodeURIComponent(fileName)}?${sasUrl.split('?')[1]}`;

                    const deletePromise = new Promise((resolve, reject) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open("DELETE", fileUrl, true);
                        xhr.onload = () => {
                            if (xhr.status === 202) {
                                console.log(`File "${fileName}" deleted successfully.`);
                                resolve();
                            } else {
                                console.error(`Failed to delete file "${fileName}".`);
                                reject(new Error(`Failed to delete ${fileName}`));
                            }
                        };
                        xhr.onerror = () => reject(new Error(`Network error deleting ${fileName}`));
                        xhr.send();
                    });

                    deletePromises.push(deletePromise);
                }

                await Promise.allSettled(deletePromises);
                await listFiles(currentPath);
            } catch (error) {
                console.error('Delete folder error:', error);
                showError(`Failed to delete folder: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Rename file
        async function renameFile(fileName) {
            const newName = prompt("Enter the new name for the file:", fileName.split('/').pop());
            if (!newName || newName === fileName.split('/').pop()) {
                return;
            }

            const validation = validateFolderName(newName);
            if (!validation.valid) {
                showError(validation.error);
                return;
            }

            try {
                const sanitizedName = validation.sanitized;
                const oldUrl = `${containerUrl}/${encodeURIComponent(fileName)}`;
                const newUrl = `${containerUrl}/${currentPath}${encodeURIComponent(sanitizedName)}?${sasUrl.split('?')[1]}`;

                const response = await new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open("PUT", newUrl, true);
                    xhr.setRequestHeader("x-ms-copy-source", oldUrl);
                    xhr.setRequestHeader("x-ms-blob-type", "BlockBlob");
                    xhr.onload = () => resolve(xhr);
                    xhr.onerror = () => reject(new Error('Network error'));
                    xhr.ontimeout = () => reject(new Error('Request timed out'));
                    xhr.timeout = 30000;
                    xhr.send();
                });

                if (response.status === 202 || response.status === 201) {
                    await deleteFile(fileName);
                    await listFiles(currentPath);
                } else {
                    showError("Failed to rename file. Please try again.");
                }
            } catch (error) {
                console.error('Rename error:', error);
                showError(`Failed to rename file: ${error.message}`);
            }
        }

        // Rename folder
        async function renameFolder(folderName) {
            const newName = prompt("Enter the new name for the folder:", folderName);
            if (!newName || newName === folderName) {
                return;
            }

            const validation = validateFolderName(newName);
            if (!validation.valid) {
                showError(validation.error);
                return;
            }

            try {
                showLoading();
                const sanitizedName = validation.sanitized;
                const oldPath = `${currentPath}${folderName}/`;
                const newPath = `${currentPath}${sanitizedName}/`;

                // Get all files in the folder
                const response = await fetch(`${containerUrl}?restype=container&comp=list&prefix=${encodeURIComponent(oldPath)}&${sasUrl.split('?')[1]}`);
                if (!response.ok) {
                    throw new Error('Failed to fetch folder contents');
                }

                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, "application/xml");
                const blobs = xml.getElementsByTagName("Blob");

                const renamePromises = [];
                for (let blob of blobs) {
                    const nameElement = blob.getElementsByTagName("Name")[0];
                    if (!nameElement) continue;

                    const oldFileName = nameElement.textContent;
                    const relativePath = oldFileName.replace(oldPath, '');
                    const newFileName = `${newPath}${relativePath}`;

                    const oldUrl = `${containerUrl}/${encodeURIComponent(oldFileName)}`;
                    const newUrl = `${containerUrl}/${encodeURIComponent(newFileName)}?${sasUrl.split('?')[1]}`;

                    const renamePromise = new Promise((resolve, reject) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open("PUT", newUrl, true);
                        xhr.setRequestHeader("x-ms-copy-source", oldUrl);
                        xhr.setRequestHeader("x-ms-blob-type", "BlockBlob");
                        xhr.onload = () => {
                            if (xhr.status === 202 || xhr.status === 201) {
                                // Delete old file
                                const deleteXhr = new XMLHttpRequest();
                                deleteXhr.open("DELETE", `${oldUrl}?${sasUrl.split('?')[1]}`, true);
                                deleteXhr.onload = () => resolve();
                                deleteXhr.onerror = () => reject(new Error('Failed to delete old file'));
                                deleteXhr.send();
                            } else {
                                reject(new Error(`Failed to copy ${oldFileName}`));
                            }
                        };
                        xhr.onerror = () => reject(new Error(`Network error copying ${oldFileName}`));
                        xhr.send();
                    });

                    renamePromises.push(renamePromise);
                }

                await Promise.allSettled(renamePromises);
                await listFiles(currentPath);
            } catch (error) {
                console.error('Rename folder error:', error);
                showError(`Failed to rename folder: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Copy link to clipboard
        async function copyLink(fileName) {
            try {
                const link = `${containerUrl}/${encodeURIComponent(fileName)}?${sasUrl.split('?')[1]}`;
                await navigator.clipboard.writeText(link);
                // Show a temporary success message
                const originalError = elements.errorMessage.style.backgroundColor;
                elements.errorMessage.style.backgroundColor = '#d4edda';
                elements.errorMessage.style.color = '#155724';
                elements.errorMessage.textContent = 'Link copied to clipboard!';
                elements.errorMessage.classList.add('show');
                setTimeout(() => {
                    elements.errorMessage.classList.remove('show');
                    elements.errorMessage.style.backgroundColor = '';
                    elements.errorMessage.style.color = '';
                }, 2000);
            } catch (error) {
                console.error('Copy link error:', error);
                showError('Failed to copy link to clipboard.');
            }
        }

        // Event listeners setup
        function setupEventListeners() {
            // Button event listeners
            elements.backButton.addEventListener('click', goBack);
            elements.createFolderButton.addEventListener('click', openCreateFolderModal);
            elements.uploadButton.addEventListener('click', () => elements.fileInput.click());
            elements.fileInput.addEventListener('change', uploadFile);
            elements.createFolderSubmit.addEventListener('click', createFolder);

            // Modal close button
            const closeButton = elements.createFolderModal.querySelector('.close');
            closeButton.addEventListener('click', closeCreateFolderModal);

            // Close modal on outside click
            elements.createFolderModal.addEventListener('click', (e) => {
                if (e.target === elements.createFolderModal) {
                    closeCreateFolderModal();
                }
            });

            // Close modal on Escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (elements.createFolderModal.classList.contains('show')) {
                        closeCreateFolderModal();
                    }
                    closeAllDropdowns();
                }
            });

            // Submit folder creation on Enter key
            elements.newFolderName.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createFolder();
                }
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.three-dot-btn') && !event.target.closest('.dropdown-menu')) {
                    closeAllDropdowns();
                }
            });

            // Keyboard navigation for file items
            document.addEventListener('keydown', (e) => {
                const fileItems = Array.from(elements.fileList.querySelectorAll('.file-item'));
                const currentIndex = fileItems.findIndex(item => item === document.activeElement);

                if (currentIndex !== -1) {
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        const nextIndex = Math.min(currentIndex + 1, fileItems.length - 1);
                        fileItems[nextIndex].focus();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        const prevIndex = Math.max(currentIndex - 1, 0);
                        fileItems[prevIndex].focus();
                    }
                }
            });
        }

        // Initialize the application
        function initApp() {
            initializeElements();
            setupEventListeners();
            listFiles();
        }

        // Start the application when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>

